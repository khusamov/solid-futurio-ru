Исправления
===========

2022-02-23 [В работе]
-----------------------


https://docs.google.com/document/d/1NrzUg-G2KT_LNm6nf5bkKxIJaZFxI8QzfDEZhvcW1tA/edit

Реализовать операции начала и завершения длительных операций в рамках подсистемы Игровой сервер.

Поступательное движение и поворот - это длительные операции. Под длительностью здесь понимается не то, 
что время их выполнения может быть минуты, часы или годы. Длительность, с точки зрения вычислимости, 
описанной дейкстрой (см. занятие №1) означает, что мы можем наблюдать промежуточное состояние этого 
объекта в процессе выполнения длительной операции. Другими словами длительная операция - это операция, 
которая выполняется не атомарным образом. А значит у этой операции есть начало и конец. 

В рамках этого домашнего задания предстоит реализовать операции начала длительной операции Start 
и завершения длительной операции End.

Для реализации этой задачи предположим, что у нас все операции, например, move, rotate, 
имеют один общий интерфейс:

interface Command
{
void Execute();
}

Все команды игры хранятся в очереди Queue. Как будет производиться работа с очередью - будет определено 
в следующих ДЗ. Сейчас достаточно считать, что результат работы команды Start Заключается в том, что команда, н
апример, Move или Rotate, ставится в очередь, а результат команды End заключается в том, что соответствующая команда, 
например,  Move или Rotate, удаляется из очереди команд.

Level #1:
Реализована операция StartMoveCommand

1.1. Определен интерфейс MoveCommandStartable, с помощью которого можно получить 
экземпляр UObject - объект, который будет двигаться по прямой, целочисленное значение 
Velocity - модуль мгновенной скорости, с которой начинает двигаться объект, 
Queue<Command> - очередь команд, куда будет записана команда созданная команда Move.

!Обратить внимание. Интерфейс MoveCommandStartable будет оберткой не над космическим кораблем 
или торпедой, а над приказом, который главнокомандующий флотом отправляет своему кораблю. 
Этот приказ тоже будет представлен UObject (приказ передается от одного процесса к другому 
и требует сериализации.десериализации). Приказ можно представить себе как следующий json-объект:

{
“id”: “уникальный идентификатор объекта, которому отдан приказ”,
“action”: “код операции”, //например, “startMove”, “stopMove”, “fire” и т.д.
// параметры, специфичные для самого приказа
“velocity”: 2
}


1.2. Реализована команда StartMoveCommand, которая
- записывает значение скорости в движущийся объект,
  !Указание. Изменение скорости лучше сделать через отдельную команду, 
  для которой определен отдельный интерфейс для изменения скорости.

- создает адаптер MovableAdapter для движущегося объекта,
- создает команду MoveCommand
- кладет команду MoveCommand в очередь

Реализована операция EndMoveCommand

2.1. Реализован интерфейс MoveCommandEndable, который возвращает команду Move, которую необходимо завершить, 
объект, который движется с помощью данной команды, очередь команд Queue<Command>

2.2. Реализована команда EndMoveCommand, которая
- удаляет значение скорости из движущегося объекта.
  !Указание. Самая простая реализация потребует добавление в интерфейс UObject метода, 
  который удаляет значение по ключу. Вообще, это является нарушением OCP, но предлагаю 
  сделать сейчас так, чтобы не усложнять понимание всего процесса работы с SOLID на данном этапе обучения.

- удаляет команду Move из Очереди команд.
  !Указание. Это не самый оптимальный вариант реализации, так как потребует просматривать команды, 
  которые находятся в очереди и временные затраты на эту операцию будут пропорциональны длине очереди.
